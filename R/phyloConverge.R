require('rphast')

#'Computes bias-corrected conservation/acceleration score of a given feature using maximum likelihood estimation of branch scaling and phylogenetic permulations (phylogeny-aware permutation test)
#' @param foregrounds a character vector containing the names of the foreground species
#' @param permulated_foregrounds a list object containing the sets of fake foreground species generated by permulation
#' @param neutralMod neutral nucleutide substitution model
#' @param maf an MSA object containing the sequence alignment
#' @param refseq reference species
#' @param feature a feature object containing information on chromosomes, coordinates, and names (optional) of the features to be scored
#' @param alpha target significance level to control for
#' @param min.fg minimum number of foreground species required
#' @param method scoring method for phyloP (default "LRT")
#' @param mode scoring mode for phyloP (default "CONACC")
#' @param adapt Boolean flag for performing adaptive permulation (adapt = TRUE for adaptive permulation, adapt = FALSE for complete permulations, default TRUE)
#' @return out a data frame containing phyloConverge permulation p-values, corrected score, and uncorrected score (negative score denotes acceleration, positive score denotes deceleration)
#' @export
phyloConverge=function(foregrounds, permulated_foregrounds, neutralMod, maf, refseq, feature=NULL, alpha=0.05, min.fg=2, method="LRT", mode="CONACC", adapt=T){
  fg_exist = checkForegrounds(maf, foregrounds)
  if (is.null(feature)){
    feature = convertAlignmentToFeature(maf, refseq)
  }
  if (length(unique(feature$feature) == 1)){
    if (unique(feature$feature)=='.'){
      feature_names = paste0("feature", seq(1, nrow(feature),1))
    }
  }
  if (length(fg_exist) >= min.fg){
    out = NULL
    for (i in 1:nrow(feature)){
      print(paste("Scoring feature", i, "/", nrow(feature), feature_names[i]))
      out_i = run_phyloConverge(fg_exist, permulated_foregrounds, neutralMod, maf, refseq, feature=feature[i,], alpha=alpha, min.fg=min.fg, method=method, mode=mode, adapt=adapt)
      out = rbind(out, out_i)
    }
  } else {
    permPval = rep(NA,nrow(feature))
    observed.score = rep(NA,nrow(feature))
    corr_score = rep(NA,nrow(feature))
    out = data.frame("permPval"=permPval, "corr_score"=corr_score, "uncorr_score"=observed.score)
  }
  out$feature = feature_names
  out
}

#' @keywords internal
run_phyloConverge=function(foregrounds, permulated_foregrounds, neutralMod, maf, refseq, feature=NULL, alpha=0.05, min.fg=2, method="LRT", mode="CONACC", adapt=T){
  observed.score = phyloP(neutralMod, msa=maf, features=feature, method="LRT", mode="CONACC", branches=foregrounds)
  observed.score = observed.score$score
  if (adapt){
    max_permulations = length(permulated_foregrounds)
    maxnum_extreme = round(alpha*max_permulations) ### centering on median --> the same pruning threshold on both sides
    permulated_scores = rep(NA, length(permulated_foregrounds))
    for (i in 1:length(permulated_foregrounds)){
      fg_exist = checkForegrounds(maf, permulated_foregrounds[[i]])
      if (length(fg_exist) >= min.fg){
        permulated_score_i = phyloP(neutralMod, msa=maf, features=feature, method="LRT", mode="CONACC", branches=fg_exist)
        permulated_scores[i] = permulated_score_i$score
        computed_permulated_scores = permulated_scores[!is.na(permulated_scores)]
        if (length(computed_permulated_scores) >= 2*maxnum_extreme){
          median_null_scores = median(computed_permulated_scores)
          if (observed.score <= median_null_scores){
            one_sided_null_scores = computed_permulated_scores[which(computed_permulated_scores < median_null_scores)]
            ind_nonextreme = which(one_sided_null_scores > observed.score)
            ind_extreme = which(one_sided_null_scores <= observed.score)
          } else if (observed.score > median_null_scores){
            one_sided_null_scores = computed_permulated_scores[which(computed_permulated_scores > median_null_scores)]
            ind_nonextreme = which(one_sided_null_scores < observed.score)
            ind_extreme = which(one_sided_null_scores >= observed.score)
          }

          if (length(ind_extreme) > maxnum_extreme || i == length(permulated_foregrounds)){
            permPval = min(maxnum_extreme+1, length(ind_extreme)+1)/(length(one_sided_null_scores)+1)   ###min(length(computed_permulated_scores)+1, length(permulated_foregrounds)+1)
            corr_score = sign(observed.score-median_null_scores)*(-log10(permPval))
            break
          }
        }
      }
    }
  } else {
    permulated_scores = rep(NA, length(permulated_foregrounds))
    for (i in 1:length(permulated_foregrounds)){
      fg_exist = checkForegrounds(maf, permulated_foregrounds[[i]])
      if (length(fg_exist) >= min.fg){
        permulated_score_i = phyloP(neutralMod, msa=maf, features=feature, method="LRT", mode="CONACC", branches=fg_exist)
        permulated_scores[i] = permulated_score_i$score
      }
    }
    computed_permulated_scores = permulated_scores[!is.na(permulated_scores)]
    median_null_scores = median(computed_permulated_scores)
    if (observed.score <= median_null_scores){
      one_sided_null_scores = computed_permulated_scores[which(computed_permulated_scores < median_null_scores)]
      ind_extreme = which(one_sided_null_scores <= observed.score)
    } else if (observed.score > median_null_scores){
      one_sided_null_scores = computed_permulated_scores[which(computed_permulated_scores > median_null_scores)]
      ind_extreme = which(one_sided_null_scores >= observed.score)
    }

    permPval = (length(ind_extreme)+1)/(length(one_sided_null_scores)+1)
    corr_score = sign(observed.score - median_null_scores)*(-log10(permPval))
  }
  out = data.frame("permPval"=permPval, "corr_score"=corr_score, "uncorr_score"=observed.score)
  out
}



#'Scan a given sequence alignment to compute bias-corrected conservation/acceleration scores
#' @param maf an MSA object containing the sequence alignment
#' @param foregrounds a character vector containing the names of the foreground species
#' @param permulated_foregrounds a list object containing the sets of fake foreground species generated by permulation
#' @param neutralMod neutral nucleutide substitution model
#' @param refseq reference species
#' @param offset offset for the coordinates in the alignment. If NULL, the offset specified in the alignment is used
#' @param stride interval (in bp) of positions of sliding windows to be scored (default 1, meaning scoring every nucleotide)
#' @param window size (in bp) of the sliding windows to be scored (default 1)
#' @param alpha target significance level to control for
#' @param min.fg minimum number of foreground species required
#' @param method scoring method for phyloP (default "LRT")
#' @param mode scoring mode for phyloP (default "CONACC")
#' @param adapt Boolean flag for performing adaptive permulation (adapt = TRUE for adaptive permulation, adapt = FALSE for complete permulations, default TRUE)
#' @return out_df a data frame containing the start and end coordinates of the sliding windows and their corresponding phyloConverge scores
#' @export
scanWithPhyloConverge=function(maf, foregrounds, permulated_foregrounds, neutralMod, refseq, offset=NULL, stride=1, window=1, alpha=0.05, min.fg=2, method="LRT", mode="CONACC", adapt=T){
  if (is.null(offset)){
    offset=maf$offset
    coord_range = coord.range.msa(maf) - offset
  } else {
    offset=offset
    coord_range = coord.range.msa(maf)
  }

  flank = (window-1)/2
  start_pos = (window-1)/2 + 1
  scored_pos = seq(start_pos, coord_range[2], stride)

  bed_table = data.frame("chr"=rep("chr1", length(scored_pos)), "start"=scored_pos-flank, "end"=scored_pos+flank, "pos"=as.character(scored_pos))
  featureout = convertBedToFeature(bed_table, refseq)

  scan_score = rep(NA, nrow(featureout))
  for (i in 1:nrow(featureout)){
    print(i)
    score_i = phyloConverge(foregrounds, permulated_foregrounds, neutralMod, maf, refseq, featureout[i,], alpha=alpha, min.fg=min.fg, method=method, mode=mode, adapt=adapt)
    scan_score[i] = score_i$corr_score
  }
  position = offset + scored_pos

  out_df = data.frame("start"=position-flank, "end"=position+flank, "corr_score"=scan_score)
  out_df
}
